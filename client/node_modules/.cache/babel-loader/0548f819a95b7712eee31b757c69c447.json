{"ast":null,"code":"/**\n * @hidden\n *\n * Render the svg <path> element.\n *\n * @param points (array) Represents the points coordinates as an array of tuples.\n * @param command (function) The command that is used (bezierCommand, lineCommand).\n *      @param point (array) [x,y] Represents the current point coordinates.\n *      @param i (integer) Represents the index of 'point' in the array 'a'.\n *      @param a (array) Represents the complete array of points coordinates.\n *      @output (string) a svg path command.\n * @output (string) a Svg <path> element\n */\nexport var svgPath = function svgPath(points, command) {\n  if (points.length === 0) {\n    return '';\n  }\n  // build the d attributes by looping over the points\n  var d = points.reduce(function (acc, point, i, a) {\n    return i === 0 ?\n    // if first point\n    \"M \".concat(point[0], \",\").concat(point[1]) :\n    // else\n    \"\".concat(acc, \" \").concat(command(point, i, a));\n  }, '');\n  return \"<path d=\\\"\".concat(d, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"1\\\"/>\");\n};\n/**\n * @hidden\n *\n * Returns the properties of a line.\n *\n * @param pointA (array) [x,y] Represents the start point coordinates.\n * @param pointB (array) [x,y] Represents the end point coordinates.\n * @output (object) { length: (integer), angle: (integer) }\n */\nexport var line = function line(pointA, pointB) {\n  var lengthX = pointB[0] - pointA[0];\n  var lengthY = pointB[1] - pointA[1];\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  };\n};\n/**\n * @hidden\n *\n * Create a function to calculate the position of the control point.\n *\n * @param lineCalc (function) Represents the line function.\n *      @param pointA (array) [x,y] Represents the start point coordinates.\n *      @param pointB (array) [x,y] Represents the end point coordinates.\n *      @output (object) { length: (integer), angle: (integer) }\n * @output (function) closure.\n *      @param current (array) [x, y] Represents the current point coordinates.\n *      @param previous (array) [x, y] Represents the previous point coordinates.\n *      @param next (array) [x, y] ]Represents the next point coordinates.\n *      @param reverse (boolean, optional) Sets the direction.\n *      @output (array) [x, y] coordinates of a control point.\n */\nexport var controlPoint = function controlPoint(lineCalc) {\n  return function (current, previous, next, reverse) {\n    // when 'current' is the first or last point of the array\n    // 'previous' and 'next' are undefined \n    // replace with 'current'\n    var p = previous || current;\n    var n = next || current;\n    var smooth = 0.1;\n    // properties of the line between previous and next \n    var l = lineCalc(p, n);\n    // If is end-control-point, add PI to the angle to go backward\n    var angle = l.angle + (reverse ? Math.PI : 0);\n    var length = l.length * smooth;\n    // The control point position is relative to the current point\n    var x = current[0] + Math.cos(angle) * length;\n    var y = current[1] + Math.sin(angle) * length;\n    return [x, y];\n  };\n};\n/**\n * @hidden\n *\n * Create a function to calculate a bezier curve command.\n *\n * @param controlPointCalc (function) Represents the controlPoint function.\n *      @param current (array) [x, y] Represents the current point coordinates.\n *      @param previous (array) [x, y] Represents the previous point coordinates.\n *      @param next (array) [x, y] ]Represents the next point coordinates.\n *      @param reverse (boolean, optional) Sets the direction.\n *      @output (array) [x, y] coordinates of a control point.\n * @output (function) closure.\n *      @param point (array) [x,y] Represents the current point coordinates.\n *      @param i (integer) Represents the index of 'point' in the array 'a'.\n *      @param a (array) Represents the complete array of points coordinates.\n *      @output (string) 'C x2,y2 x1,y1 x,y' Cubic bezier command.\n */\nexport var bezierCommand = function bezierCommand(controlPointCalc) {\n  return function (point, i, a) {\n    // start control point\n    var _a = controlPointCalc(a[i - 1], a[i - 2], point),\n      cpsX = _a[0],\n      cpsY = _a[1];\n    // end control point\n    var _b = controlPointCalc(point, a[i - 1], a[i + 1], true),\n      cpeX = _b[0],\n      cpeY = _b[1];\n    return \"C \".concat(cpsX, \",\").concat(cpsY, \" \").concat(cpeX, \",\").concat(cpeY, \" \").concat(point[0], \",\").concat(point[1]);\n  };\n};","map":null,"metadata":{},"sourceType":"module"}