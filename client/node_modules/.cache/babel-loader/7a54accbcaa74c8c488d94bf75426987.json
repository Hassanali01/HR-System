{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { FormContext } from './FormContext';\nimport { getter, setter, clone, cloneObject, guid } from '@progress/kendo-react-common';\nimport { validatePackage } from '@progress/kendo-react-common';\nimport { packageMetadata } from './package-metadata';\n/**\n * @hidden\n */\nvar FORCEUPDATE_ACCUMULATOR_TIMEOUT = 0;\n/**\n * Represents the [KendoReact Form component]({% slug overview_form %}).\n *\n * @example\n * ```jsx\n * export const FormInput = (fieldRenderProps) => {\n *     const onValueChange = React.useCallback(\n *         (event) => fieldRenderProps.onChange(event.target.value),\n *         [fieldRenderProps.onChange]\n *     );\n *     return (\n *         <input\n *             className={'k-input'}\n *             value={fieldRenderProps.value}\n *             onChange={onValueChange}\n *         />\n *     );\n * };\n *\n * export const App = () => {\n *     const handleSubmit = (dataItem) => alert(JSON.stringify(dataItem));\n *     return (\n *         <Form\n *             initialValues={{title: ''}}\n *             onSubmit={handleSubmit}\n *             render={(formRenderProps) => (\n *                 <div>\n *                     <Field name={'title'} component={FormInput} />\n *                     <button\n *                         className=\"k-button\"\n *                         disabled={!formRenderProps.allowSubmit}\n *                         onClick={formRenderProps.onSubmit}\n *                     >\n *                         Submit\n *                     </button>\n *                 </div>\n *             )}\n *         />\n *     );\n * };\n *\n * ReactDOM.render(<App />, document.querySelector('my-app'));\n * ```\n */\nvar Form = /** @class */function (_super) {\n  __extends(Form, _super);\n  /**\n   * @hidden\n   */\n  function Form(props) {\n    var _this = _super.call(this, props) || this;\n    _this._id = guid();\n    _this._touched = {};\n    _this._visited = {};\n    _this._modified = {};\n    _this._validatorsByField = {};\n    _this._values = {};\n    _this._fields = {};\n    _this._unmounted = false;\n    _this._submitted = false;\n    /**\n     * @hidden\n     */\n    _this.isValid = function () {\n      return _this.isFormValid(_this.errors);\n    };\n    /**\n     * @hidden\n     */\n    _this.accumulatedForceUpdate = function () {\n      // IMPORTANT:\n      // Should only be used for updates not comming from editors as it\n      // will cause cursor jump as react will reset the editor to old value\n      if (_this._accumulatorTimeout) {\n        clearTimeout(_this._accumulatorTimeout);\n      }\n      _this._accumulatorTimeout = window.setTimeout(function () {\n        _this._accumulatorTimeout = undefined;\n        _this.forceUpdate();\n      }, FORCEUPDATE_ACCUMULATOR_TIMEOUT);\n    };\n    /**\n     * @hidden\n     */\n    _this.resetForm = function () {\n      _this.values = clone(_this.props.initialValues);\n      _this._id = guid();\n      _this._touched = {};\n      _this._visited = {};\n      _this._modified = {};\n      _this._validatorsByField = {};\n      _this._fields = {};\n      _this._submitted = false;\n      _this.forceUpdate();\n    };\n    /**\n     * Method for resetting the form state outside the form component.\n     *\n     * > Use `onReset` only if you cannot achieve the desired behavior through the Field component or by FormRenderProps.\n     */\n    _this.onReset = function () {\n      return _this.resetForm();\n    };\n    /**\n     * @hidden\n     */\n    _this.addField = function (field) {\n      _this._fields[field] = true;\n    };\n    /**\n     * @hidden\n     */\n    _this.onSubmit = function (event) {\n      var touchedVisited = {};\n      var fields = _this.fields;\n      if (event) {\n        if (typeof event.preventDefault === 'function') {\n          event.preventDefault();\n        }\n        if (typeof event.stopPropagation === 'function') {\n          event.stopPropagation();\n        }\n      }\n      fields.forEach(function (fieldName) {\n        touchedVisited[fieldName] = true;\n      });\n      // show validations\n      _this.visited = __assign({}, touchedVisited);\n      _this.touched = __assign({}, touchedVisited);\n      var values = _this.values;\n      var isValid = _this.isFormValid(_this.errors);\n      var isModified = _this.isFormModified(_this.modified, fields);\n      if (_this.props.onSubmitClick) {\n        _this.props.onSubmitClick.call(undefined, {\n          values: values,\n          isValid: isValid,\n          isModified: isModified,\n          event: event\n        });\n      }\n      if (isValid && (_this.props.ignoreModified || isModified) && _this.props.onSubmit) {\n        _this._submitted = true;\n        _this.props.onSubmit.call(undefined, values, event);\n      }\n      _this.forceUpdate();\n    };\n    /**\n     * Method for emiting changes to a specific field outside the form component.\n     *\n     * > Use `onChange` only if you cannot achieve the desired behavior through the Field component by FormRenderProps.\n     */\n    _this.onChange = function (name, options) {\n      var _a;\n      var value = options.value;\n      _this.addField(name);\n      if (!_this.modified[name]) {\n        _this.modified = __assign(__assign({}, _this.modified), (_a = {}, _a[name] = true, _a));\n      }\n      _this.valueSetter(name, value);\n      _this.forceUpdate();\n    };\n    /**\n     * @hidden\n     */\n    _this.onFocus = function (name, skipForceUpdate) {\n      var _a;\n      if (_this.visited[name]) {\n        return;\n      }\n      _this.visited = __assign(__assign({}, _this.visited), (_a = {}, _a[name] = true, _a));\n      if (!skipForceUpdate) {\n        _this.forceUpdate();\n      }\n    };\n    /**\n     * @hidden\n     */\n    _this.onBlur = function (name, skipForceUpdate) {\n      var _a;\n      if (_this.touched[name]) {\n        return;\n      }\n      _this.onFocus(name, skipForceUpdate);\n      _this.touched = __assign(__assign({}, _this.touched), (_a = {}, _a[name] = true, _a));\n      if (!skipForceUpdate) {\n        _this.forceUpdate();\n      }\n    };\n    /**\n     * @hidden\n     */\n    _this.onFieldRegister = function (name, validator) {\n      var _a;\n      _this.addField(name);\n      // The sole reason for using class props over state - nextIndex, needed for destroying validators\n      var oldValidators = _this.validatorsByField[name] || [];\n      var nextIndex = oldValidators.length;\n      _this.validatorsByField = __assign(__assign({}, _this.validatorsByField), (_a = {}, _a[name] = __spreadArray(__spreadArray([], oldValidators, true), [validator], false), _a));\n      _this.accumulatedForceUpdate();\n      return function () {\n        var _a;\n        // onFieldUnregister:\n        if (_this._unmounted) {\n          return;\n        }\n        var newValidators = __spreadArray([], _this.validatorsByField[name] || [], true);\n        var validatorIsUnregistered = Boolean(newValidators[nextIndex]);\n        newValidators[nextIndex] = undefined;\n        _this.validatorsByField = __assign(__assign({}, _this.validatorsByField), (_a = {}, _a[name] = newValidators, _a));\n        if (validatorIsUnregistered) {\n          _this.accumulatedForceUpdate();\n        }\n      };\n    };\n    /**\n     * @hidden\n     */\n    _this.isFormValid = function (errors) {\n      return !Object.keys(errors).some(function (fieldName) {\n        return Boolean(errors[fieldName]);\n      });\n    };\n    /**\n     * @hidden\n     */\n    _this.isFormModified = function (modified, fields) {\n      return fields.some(function (fieldName) {\n        return modified[fieldName];\n      });\n    };\n    /**\n     * @hidden\n     */\n    _this.isFormHasNotTouched = function (touched, fields) {\n      return fields.some(function (fieldName) {\n        return !touched[fieldName];\n      });\n    };\n    /**\n     * @hidden\n     */\n    _this.isFormTouched = function (touched, fields) {\n      return fields.some(function (fieldName) {\n        return touched[fieldName];\n      });\n    };\n    /**\n     * @hidden\n     */\n    _this.isFormVisited = function (visited, fields) {\n      return fields.some(function (fieldName) {\n        return visited[fieldName];\n      });\n    };\n    /**\n     * @hidden\n     */\n    _this.valueGetter = function (fieldName) {\n      return getter(fieldName)(_this.values);\n    };\n    /**\n     * @hidden\n     */\n    _this.valueSetter = function (fieldName, value) {\n      return setter(fieldName)(_this.values, value);\n    };\n    /**\n     * @hidden\n     */\n    _this.onArrayAction = function (name) {\n      var _a;\n      _this.addField(name);\n      if (!_this.modified[name]) {\n        _this.modified = __assign(__assign({}, _this.modified), (_a = {}, _a[name] = true, _a));\n      }\n      _this.onBlur(name, true);\n    };\n    /**\n     * @hidden\n     */\n    _this.onInsert = function (name, options) {\n      _this.onArrayAction(name);\n      var newArray = __spreadArray([], _this.valueGetter(name) || [], true);\n      newArray.splice(options.index, 0, options.value);\n      _this.valueSetter(name, newArray);\n      _this.forceUpdate();\n    };\n    /**\n     * @hidden\n     */\n    _this.onUnshift = function (name, options) {\n      _this.onInsert(name, {\n        value: options.value,\n        index: 0\n      });\n    };\n    /**\n     * @hidden\n     */\n    _this.onPush = function (name, options) {\n      _this.onArrayAction(name);\n      var newArray = __spreadArray(__spreadArray([], _this.valueGetter(name) || [], true), [options.value], false);\n      _this.valueSetter(name, newArray);\n      _this.forceUpdate();\n    };\n    /**\n     * @hidden\n     */\n    _this.onPop = function (name) {\n      _this.onArrayAction(name);\n      var newArray = __spreadArray([], _this.valueGetter(name) || [], true);\n      var value = newArray.pop();\n      _this.valueSetter(name, newArray);\n      _this.forceUpdate();\n      return value;\n    };\n    /**\n     * @hidden\n     */\n    _this.onRemove = function (name, options) {\n      _this.onArrayAction(name);\n      var newArray = __spreadArray([], _this.valueGetter(name) || [], true);\n      var value = newArray.splice(options.index, 1);\n      _this.valueSetter(name, newArray);\n      _this.forceUpdate();\n      return value;\n    };\n    /**\n     * @hidden\n     */\n    _this.onReplace = function (name, options) {\n      _this.onArrayAction(name);\n      var newArray = __spreadArray([], _this.valueGetter(name) || [], true);\n      newArray.splice(options.index, 1, options.value);\n      _this.valueSetter(name, newArray);\n      _this.forceUpdate();\n    };\n    /**\n     * @hidden\n     */\n    _this.onMove = function (name, options) {\n      _this.onArrayAction(name);\n      var newArray = __spreadArray([], _this.valueGetter(name) || [], true);\n      var value = newArray[options.prevIndex];\n      newArray.splice(options.prevIndex, 1);\n      newArray.splice(options.nextIndex, 0, value);\n      _this.valueSetter(name, newArray);\n      _this.forceUpdate();\n    };\n    validatePackage(packageMetadata);\n    _this.values = clone(props.initialValues);\n    return _this;\n  }\n  Object.defineProperty(Form.prototype, \"touched\", {\n    /**\n     * @hidden\n     */\n    get: function get() {\n      return this._touched;\n    },\n    /**\n     * @hidden\n     */\n    set: function set(value) {\n      this._touched = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Form.prototype, \"visited\", {\n    /**\n     * @hidden\n     */\n    get: function get() {\n      return this._visited;\n    },\n    /**\n     * @hidden\n     */\n    set: function set(value) {\n      this._visited = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Form.prototype, \"modified\", {\n    /**\n     * @hidden\n     */\n    get: function get() {\n      return this._modified;\n    },\n    /**\n     * @hidden\n     */\n    set: function set(value) {\n      this._modified = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Form.prototype, \"validatorsByField\", {\n    /**\n     * @hidden\n     */\n    get: function get() {\n      return this._validatorsByField;\n    },\n    /**\n     * @hidden\n     */\n    set: function set(value) {\n      this._validatorsByField = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Form.prototype, \"values\", {\n    /**\n     * @hidden\n     */\n    get: function get() {\n      return this._values;\n    },\n    /**\n     * @hidden\n     */\n    set: function set(value) {\n      this._values = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Form.prototype, \"fields\", {\n    /**\n     * @hidden\n     */\n    get: function get() {\n      return Object.keys(this._fields);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Form.prototype, \"formErrors\", {\n    /**\n     * @hidden\n     */\n    get: function get() {\n      if (this.props.validator) {\n        return this.props.validator(this.values, this.valueGetter);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Form.prototype, \"errors\", {\n    /**\n     * @hidden\n     */\n    get: function get() {\n      var _this = this;\n      var errors = {};\n      var fields = this.fields;\n      var validatorsByField = this.validatorsByField;\n      fields.forEach(function (fieldName) {\n        errors[fieldName] = '';\n        if (validatorsByField[fieldName]) {\n          var validators_1 = [];\n          validatorsByField[fieldName].forEach(function (validator) {\n            if (Array.isArray(validator)) {\n              validators_1.push.apply(validators_1, validator);\n            } else {\n              validators_1.push(validator);\n            }\n          });\n          // find first validation error\n          validators_1.find(function (validator) {\n            if (validator) {\n              var result = validator(_this.valueGetter(fieldName), _this.valueGetter, {\n                name: fieldName\n              });\n              if (result) {\n                errors[fieldName] = result;\n                return true;\n              }\n            }\n            return false;\n          });\n        }\n      });\n      var formErrors = this.formErrors;\n      if (formErrors) {\n        cloneObject(this.formErrors, errors);\n      }\n      return errors;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * @hidden\n   */\n  Form.prototype.componentWillUnmount = function () {\n    this._unmounted = true;\n    if (this._accumulatorTimeout) {\n      clearTimeout(this._accumulatorTimeout);\n    }\n  };\n  /**\n   * @hidden\n   */\n  Form.prototype.render = function () {\n    var render = this.props.render;\n    var touched = this.touched;\n    var visited = this.visited;\n    var modified = this.modified;\n    var fields = this.fields;\n    var errors = this.errors;\n    var formValid = this.isFormValid(errors);\n    var formModified = this.isFormModified(modified, fields);\n    var formTouched = this.isFormTouched(touched, fields);\n    var formVisited = this.isFormVisited(visited, fields);\n    var formHasNotTouched = this.isFormHasNotTouched(touched, fields);\n    // 1. The form is not touched, but has errors - allow submit to force validation.\n    // 2. The form is valid and modified - if not modified, disable submit.\n    var allowSubmit = formHasNotTouched && !formValid || formValid && (this.props.ignoreModified || formModified);\n    return React.createElement(FormContext.Provider, {\n      key: this._id,\n      value: {\n        id: this._id,\n        valueGetter: this.valueGetter,\n        errors: errors,\n        modified: modified,\n        touched: touched,\n        visited: visited,\n        registerField: this.onFieldRegister,\n        onSubmit: this.onSubmit,\n        onChange: this.onChange,\n        onFocus: this.onFocus,\n        onBlur: this.onBlur,\n        onUnshift: this.onUnshift,\n        onPush: this.onPush,\n        onInsert: this.onInsert,\n        onPop: this.onPop,\n        onRemove: this.onRemove,\n        onReplace: this.onReplace,\n        onMove: this.onMove\n      }\n    }, render({\n      valid: formValid,\n      modified: formModified,\n      touched: formTouched,\n      visited: formVisited,\n      submitted: this._submitted,\n      valueGetter: this.valueGetter,\n      errors: errors,\n      allowSubmit: allowSubmit,\n      onChange: this.onChange,\n      onSubmit: this.onSubmit,\n      onFormReset: this.resetForm\n    }));\n  };\n  /**\n   * @hidden\n   */\n  Form.displayName = 'KendoReactForm';\n  /**\n   * @hidden\n   */\n  Form.propTypes = {\n    initialValues: PropTypes.any,\n    onSubmit: PropTypes.func,\n    onSubmitClick: PropTypes.func,\n    render: PropTypes.func.isRequired\n  };\n  return Form;\n}(React.Component);\nexport { Form };","map":null,"metadata":{},"sourceType":"module"}