{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport * as React from 'react';\nimport { FormContext } from './FormContext';\n/**\n * Represents the Field component that is used inside the KendoReact Form component.\n * It uses `name` property to access field value and meta information from Form state.\n */\nexport var Field = function Field(props) {\n  var name = props.name,\n    component = props.component,\n    validator = props.validator,\n    children = props.children,\n    onChange = props.onChange,\n    others = __rest(props, [\"name\", \"component\", \"validator\", \"children\", \"onChange\"]);\n  var form = React.useContext(FormContext);\n  var formId = form ? form.id : '';\n  React.useEffect(function () {\n    if (!form) {\n      return;\n    }\n    var unregisterField = form.registerField(name, validator);\n    return unregisterField;\n  }, [name, formId, validator]);\n  var handleOnChange = React.useCallback(function (event) {\n    // Adding a name here slows down the performance.\n    // However, the other apprach taken by Formik is to search for the `name` attribute\n    // on `event.target.value` which does not work for all KendoReact components.\n    // If Formik uses custom components like the KendoReact ones, it would take the same approach.\n    // On the other hand, ReactFinal Form performs better in both cases due to its\n    // subscribtion-based model - the fields are subscribed for changes to a given field,\n    // which prevents unnececery rerenders. Note that this might be fragile in future React versions -\n    // the current performance testing accunts for a slight lag after 300 native HTML inputs in the 120ms-200ms range.\n    var newValue = event ? event.value !== undefined ? event.value : event.target ? event.target.value : event.target : event;\n    form.onChange(name, {\n      value: newValue\n    });\n    if (onChange) {\n      onChange.call(undefined, event);\n    }\n  }, [name, formId, onChange]);\n  var onNativeComponentChange = React.useCallback(function (event) {\n    return form.onChange(name, {\n      value: event.target.value\n    });\n  }, [name, formId]);\n  var handleOnBlur = React.useCallback(function () {\n    return form.onBlur(name);\n  }, [name, formId]);\n  var handleOnFocus = React.useCallback(function () {\n    return form.onFocus(name);\n  }, [name, formId]);\n  if (!form) {\n    // TODO: For future versions - warn for missing form in dev mode\n    // if (__process.env.NODE_ENV !== 'production') { // or __DEV__\n    //     throw new Error('Field must be used inside of a <Form> component');\n    // }\n    return null;\n  }\n  var value = form.valueGetter(name);\n  // TODO: For future versions as it's better to have render prop\n  // if (typeof children === 'function') {\n  //     return children({ ...field, children: undefined, ...others });\n  // }\n  if (typeof component === 'string') {\n    // ignore meta, combine input with any other props\n    return React.createElement(component, __assign({\n      onChange: onNativeComponentChange,\n      onBlur: handleOnBlur,\n      onFocus: handleOnFocus,\n      value: value,\n      children: children\n    }, others));\n  }\n  return React.createElement(component, __assign(__assign({\n    children: children\n  }, others), {\n    // input\n    onChange: handleOnChange,\n    onBlur: handleOnBlur,\n    onFocus: handleOnFocus,\n    value: value,\n    // meta\n    validationMessage: form.errors[name],\n    touched: form.touched[name],\n    modified: form.modified[name],\n    visited: form.visited[name],\n    // Our `valid` implementation requires double submit to show html5 validation errors,\n    // however it's NOT recommended to show html5 validation errors at all as:\n    // - There is no standard way to change validation look and feel with CSS.\n    // - Look different in each browser / OS\n    // - You can have a page in one language but an error message displayed in another language (not localizable)\n    valid: !(Boolean(form.errors[name]) && form.touched[name]),\n    name: name\n  }));\n};\nField.displayName = 'KendoReactField';","map":null,"metadata":{},"sourceType":"module"}