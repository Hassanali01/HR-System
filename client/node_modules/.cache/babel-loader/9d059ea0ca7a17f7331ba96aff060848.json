{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { guid, classNames, createPropsContext, withPropsContext } from '@progress/kendo-react-common';\nimport { FloatingLabel } from '@progress/kendo-react-labels';\nimport { validatePackage } from '@progress/kendo-react-common';\nimport { packageMetadata } from '../package-metadata';\n/** @hidden */\nvar InputWithoutContext = /** @class */function (_super) {\n  __extends(InputWithoutContext, _super);\n  function InputWithoutContext(props) {\n    var _this = _super.call(this, props) || this;\n    _this._input = null;\n    _this._inputId = guid();\n    /**\n     * @hidden\n     */\n    _this.focus = function () {\n      if (_this._input) {\n        _this._input.focus();\n      }\n    };\n    _this.isInvalid = function (state) {\n      var result = false;\n      for (var prop in state) {\n        if (state.hasOwnProperty(prop)) {\n          result = result || Boolean(state[prop]);\n        }\n      }\n      return result;\n    };\n    /**\n     * @hidden\n     */\n    _this.setValidity = function () {\n      if (_this._input && _this._input.setCustomValidity) {\n        _this.validity.valid || !_this.validityStyles ? _this._input.classList.remove('k-invalid') : _this._input.classList.add('k-invalid');\n        _this._input.setCustomValidity(_this.validity.valid ? '' : _this.props.validationMessage || '');\n      }\n    };\n    _this.handleChange = function (event) {\n      _this.setState({\n        value: event.target.value\n      });\n      _this.valueDuringOnChange = event.target.value;\n      if (_this.props.onChange) {\n        _this.props.onChange.call(undefined, {\n          syntheticEvent: event,\n          nativeEvent: event.nativeEvent,\n          value: event.target.value,\n          target: _this\n        });\n      }\n      _this.valueDuringOnChange = undefined;\n    };\n    /**\n     * @hidden\n     */\n    _this.handleAutoFill = function (e) {\n      if (e.animationName === 'autoFillStart') {\n        var parent_1 = e.target.parentNode;\n        if (parent_1 && parent_1.classList.contains('k-empty')) {\n          parent_1.classList.remove('k-empty');\n        }\n      }\n    };\n    validatePackage(packageMetadata);\n    _this.state = {\n      value: _this.props.defaultValue || InputWithoutContext.defaultProps.defaultValue\n    };\n    return _this;\n  }\n  Object.defineProperty(InputWithoutContext.prototype, \"element\", {\n    /**\n     * Gets the native input element of the Input component.\n     */\n    get: function get() {\n      return this._input;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InputWithoutContext.prototype, \"value\", {\n    /**\n     * Gets the value of the Input.\n     */\n    get: function get() {\n      return this.valueDuringOnChange !== undefined ? this.valueDuringOnChange : this.props.value !== undefined ? this.props.value : this.state.value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InputWithoutContext.prototype, \"name\", {\n    /**\n     * Gets the `name` property of the Input.\n     */\n    get: function get() {\n      return this.props.name;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InputWithoutContext.prototype, \"validity\", {\n    /**\n     * Represents the validity state into which the Input is set.\n     */\n    get: function get() {\n      var result = {\n        badInput: this._input ? this._input.validity.badInput : false,\n        patternMismatch: this._input ? this._input.validity.patternMismatch : false,\n        rangeOverflow: this._input ? this._input.validity.rangeOverflow : false,\n        rangeUnderflow: this._input ? this._input.validity.rangeUnderflow : false,\n        stepMismatch: this._input ? this._input.validity.stepMismatch : false,\n        tooLong: this._input ? this._input.validity.tooLong : false,\n        typeMismatch: this._input ? this._input.validity.typeMismatch : false,\n        valueMissing: this._input ? this._input.validity.valueMissing : false\n      };\n      return __assign(__assign({}, result), {\n        customError: this.props.validationMessage !== undefined,\n        valid: this.props.valid !== undefined ? this.props.valid : this._input ? !this.isInvalid(result) : true\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InputWithoutContext.prototype, \"validityStyles\", {\n    /**\n     * @hidden\n     */\n    get: function get() {\n      return this.props.validityStyles !== undefined ? this.props.validityStyles : InputWithoutContext.defaultProps.validityStyles;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * @hidden\n   */\n  InputWithoutContext.prototype.componentDidMount = function () {\n    this.forceUpdate();\n  };\n  /**\n   * @hidden\n   */\n  InputWithoutContext.prototype.componentDidUpdate = function () {\n    this.setValidity();\n  };\n  /**\n   * @hidden\n   */\n  InputWithoutContext.prototype.render = function () {\n    var _this = this;\n    var _a = this.props,\n      className = _a.className,\n      label = _a.label,\n      id = _a.id,\n      validationMessage = _a.validationMessage,\n      defaultValue = _a.defaultValue,\n      valid = _a.valid,\n      // Removed to support direct use in Form Field component\n      visited = _a.visited,\n      touched = _a.touched,\n      modified = _a.modified,\n      ariaLabelledBy = _a.ariaLabelledBy,\n      ariaDescribedBy = _a.ariaDescribedBy,\n      validityStyles = _a.validityStyles,\n      style = _a.style,\n      ariaLabel = _a.ariaLabel,\n      props = __rest(_a, [\"className\", \"label\", \"id\", \"validationMessage\", \"defaultValue\", \"valid\", \"visited\", \"touched\", \"modified\", \"ariaLabelledBy\", \"ariaDescribedBy\", \"validityStyles\", \"style\", \"ariaLabel\"]);\n    var inputId = id || this._inputId;\n    var isValid = !this.validityStyles || this.validity.valid;\n    var inputClassName = classNames(className, 'k-input k-input-md k-rounded-md k-input-solid');\n    var textbox = React.createElement(\"input\", __assign({\n      \"aria-labelledby\": ariaLabelledBy,\n      \"aria-describedby\": ariaDescribedBy,\n      \"aria-disabled\": this.props.disabled || undefined,\n      \"aria-invalid\": !isValid || undefined,\n      \"aria-label\": ariaLabel || undefined\n    }, props, {\n      style: !label ? style : undefined,\n      value: this.value,\n      id: inputId,\n      className: inputClassName,\n      onChange: this.handleChange,\n      onAnimationStart: this.handleAutoFill,\n      ref: function ref(el) {\n        _this._input = el;\n      }\n    }));\n    return label ? React.createElement(FloatingLabel, {\n      label: label,\n      editorId: inputId,\n      editorValue: String(this.value),\n      editorValid: isValid,\n      editorDisabled: props.disabled,\n      editorPlaceholder: props.placeholder,\n      children: textbox,\n      style: style,\n      dir: props.dir\n    }) : textbox;\n  };\n  InputWithoutContext.displayName = 'Input';\n  /**\n   * @hidden\n   */\n  InputWithoutContext.propTypes = {\n    label: PropTypes.string,\n    validationMessage: PropTypes.string,\n    required: PropTypes.bool,\n    validate: PropTypes.bool,\n    id: PropTypes.string,\n    ariaLabelledBy: PropTypes.string,\n    ariaDescribedBy: PropTypes.string,\n    ariaLabel: PropTypes.string\n  };\n  /**\n   * @hidden\n   */\n  InputWithoutContext.defaultProps = {\n    defaultValue: '',\n    required: false,\n    validityStyles: true\n  };\n  return InputWithoutContext;\n}(React.Component);\nexport { InputWithoutContext };\n/**\n * Represents the PropsContext of the `Input` component.\n * Used for global configuration of all `Input` instances.\n *\n * For more information, refer to the [Inputs Props Context]({% slug props-context_inputs %}) article.\n */\nexport var InputPropsContext = createPropsContext();\n;\n/* eslint-disable @typescript-eslint/no-redeclare -- intentionally naming the component the same as the type */\n/**\n * Represents the [KendoReact Input component]({% slug overview_textbox %}).\n *\n * Accepts properties of type [InputProps]({% slug api_inputs_inputprops %}).\n * Obtaining the `ref` returns an object of type [InputHandle]({% slug api_inputs_inputhandle %}).\n */\nexport var Input = withPropsContext(InputPropsContext, InputWithoutContext);\nInput.displayName = 'KendoReactInput';","map":null,"metadata":{},"sourceType":"module"}