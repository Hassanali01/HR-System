{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\n/**\n * @hidden\n */\nexport var RANGE_ACTION;\n(function (RANGE_ACTION) {\n  RANGE_ACTION[\"start\"] = \"start\";\n  RANGE_ACTION[\"end\"] = \"end\";\n  RANGE_ACTION[\"min\"] = \"min\";\n  RANGE_ACTION[\"max\"] = \"max\";\n  RANGE_ACTION[\"increase\"] = \"increase\";\n  RANGE_ACTION[\"decrease\"] = \"decrease\";\n})(RANGE_ACTION || (RANGE_ACTION = {}));\n/**\n * @hidden\n */\nexport var rangeReducer = function rangeReducer(state, action) {\n  var newState;\n  var newValue;\n  switch (action.type) {\n    case RANGE_ACTION.start:\n      if (action.payload === undefined) {\n        return state;\n      }\n      newState = {\n        start: action.payload > state.end ? state.end : Math.max(action.payload, action.min),\n        end: state.end\n      };\n      break;\n    case RANGE_ACTION.end:\n      if (action.payload === undefined) {\n        return state;\n      }\n      newState = {\n        start: state.start,\n        end: action.payload < state.start ? state.start : Math.min(action.payload, action.max)\n      };\n      break;\n    case RANGE_ACTION.min:\n      if (action.key === 'start') {\n        newState = __assign(__assign({}, state), {\n          start: action.min\n        });\n      } else {\n        newState = __assign(__assign({}, state), {\n          end: Math.max(action.min, state.start)\n        });\n      }\n      break;\n    case RANGE_ACTION.max:\n      if (action.key === 'start') {\n        newState = __assign(__assign({}, state), {\n          start: Math.min(action.max, state.end)\n        });\n      } else {\n        newState = __assign(__assign({}, state), {\n          end: action.max\n        });\n      }\n      break;\n    case RANGE_ACTION.increase:\n      if (action.step === undefined || action.key === undefined) {\n        return state;\n      }\n      newValue = state[action.key] + action.step;\n      if (action.key === 'start') {\n        if (newValue < action.min) {\n          newState = __assign(__assign({}, state), {\n            start: action.min\n          });\n        } else {\n          newState = __assign(__assign({}, state), {\n            start: Math.min(newValue, state.end)\n          });\n        }\n      } else {\n        if (newValue > action.max) {\n          newState = __assign(__assign({}, state), {\n            end: action.max\n          });\n        } else {\n          newState = __assign(__assign({}, state), {\n            end: Math.max(newValue, state.start)\n          });\n        }\n      }\n      break;\n    case RANGE_ACTION.decrease:\n      if (action.step === undefined || action.key === undefined) {\n        return state;\n      }\n      newValue = state[action.key] - action.step;\n      if (action.key === 'start') {\n        if (newValue < action.min) {\n          newState = __assign(__assign({}, state), {\n            start: action.min\n          });\n        } else {\n          newState = __assign(__assign({}, state), {\n            start: Math.min(newValue, state.end)\n          });\n        }\n      } else {\n        if (newValue > action.max) {\n          newState = __assign(__assign({}, state), {\n            end: action.max\n          });\n        } else {\n          newState = __assign(__assign({}, state), {\n            end: Math.max(newValue, state.start)\n          });\n        }\n      }\n      break;\n    default:\n      newState = state;\n      break;\n  }\n  return newState;\n};","map":null,"metadata":{},"sourceType":"module"}