{"ast":null,"code":"import { exportImage, geometry, Group, MultiPath, Path, Image, Surface } from '@progress/kendo-drawing';\nimport { elementOffset, limitValue } from '../common';\nvar Point = geometry.Point,\n  Rect = geometry.Rect,\n  transform = geometry.transform;\nvar noop = function noop() {};\nvar DECIMAL_DIGITS = 3;\nvar DEFAULT_COLOR = '#000';\nvar DEFAULT_BACKGROUND_COLOR = '#fff';\nvar DEFAULT_PRECISION = 1;\nvar DEFAULT_SAMPLING_RATE = 200; // Updates per second\nvar DEFAULT_STROKE_WIDTH = 1;\nvar DEFAULT_WIDTH = 750;\nvar DEFAULT_HEIGHT = 250;\nvar DEFAULT_SCALE = 1;\n// Export images at maximized scale (3x) and 2x pixel density to cover HiDPI screens.\nvar DEFAULT_EXPORT_SCALE = 6;\nvar SignaturePad = /** @class */function () {\n  function SignaturePad(element, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.element = element;\n    this.lastMoveTime = 0;\n    this.options = Object.assign({\n      scale: DEFAULT_SCALE,\n      precision: DEFAULT_PRECISION,\n      samplingRate: DEFAULT_SAMPLING_RATE,\n      smooth: options.smooth !== false,\n      color: options.color || DEFAULT_COLOR,\n      backgroundColor: options.backgroundColor || DEFAULT_BACKGROUND_COLOR,\n      strokeWidth: DEFAULT_STROKE_WIDTH,\n      onChange: noop,\n      onDraw: noop,\n      onDrawEnd: noop\n    }, options);\n    this.pathOptions = {\n      stroke: {\n        color: this.options.color,\n        width: this.options.strokeWidth,\n        lineCap: 'round',\n        lineJoin: 'round'\n      }\n    };\n    this.initSurface();\n    this.attachEvents();\n  }\n  SignaturePad.prototype.destroy = function () {\n    this.detachEvents();\n  };\n  SignaturePad.prototype.clear = function () {\n    this.rootGroup.clear();\n    this.path = null;\n  };\n  Object.defineProperty(SignaturePad.prototype, \"isDrawing\", {\n    get: function get() {\n      return Boolean(this.points);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SignaturePad.prototype, \"pathData\", {\n    get: function get() {\n      var _a;\n      return (_a = this.path) === null || _a === void 0 ? void 0 : _a.toString(DECIMAL_DIGITS);\n    },\n    set: function set(value) {\n      this.clear();\n      this.path = MultiPath.parse(value, this.pathOptions);\n      this.rootGroup.append(this.path);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  SignaturePad.prototype.loadImage = function (data, size) {\n    if (size === void 0) {\n      size = [];\n    }\n    if (!data) {\n      this.clear();\n      return;\n    }\n    var _a = this.size,\n      width = _a[0],\n      height = _a[1];\n    var contentWidth = width / this.options.scale;\n    var contentHeight = height / this.options.scale;\n    var importWidth = size[0] || contentWidth * DEFAULT_EXPORT_SCALE;\n    var importHeight = size[1] || contentHeight * DEFAULT_EXPORT_SCALE;\n    var scaleX = contentWidth / importWidth;\n    var scaleY = contentHeight / importHeight;\n    var scale = Math.min(scaleX, scaleY);\n    var img = new Image(data, new geometry.Rect([0, 0], [importWidth, importHeight]));\n    img.transform(transform().scale(scale, scale));\n    this.clear();\n    this.rootGroup.append(img);\n  };\n  SignaturePad.prototype.exportImage = function (options) {\n    var _a;\n    var _b = this.size,\n      width = _b[0],\n      height = _b[1];\n    var contentWidth = width / this.options.scale;\n    var contentHeight = height / this.options.scale;\n    var exportWidth = (options === null || options === void 0 ? void 0 : options.width) || contentWidth * DEFAULT_EXPORT_SCALE;\n    var exportHeight = (options === null || options === void 0 ? void 0 : options.height) || contentHeight * DEFAULT_EXPORT_SCALE;\n    var scaleX = exportWidth / contentWidth;\n    var scaleY = exportHeight / contentHeight;\n    var scale = Math.min(scaleX, scaleY);\n    var exportRect = new Rect([0, 0], [exportWidth, exportHeight]);\n    var exportGroup = new Group({\n      clip: Path.fromRect(exportRect)\n    });\n    var contentGroup = new Group({\n      transform: transform().scale(scale, scale)\n    });\n    var frame = Path.fromRect(exportRect, {\n      fill: {\n        color: this.options.backgroundColor\n      }\n    });\n    exportGroup.append(frame);\n    exportGroup.append(contentGroup);\n    (_a = contentGroup.children).push.apply(_a, this.rootGroup.children);\n    return exportImage(exportGroup, Object.assign({\n      width: exportWidth,\n      height: exportHeight\n    }, options));\n  };\n  SignaturePad.prototype.resize = function () {\n    this.surface.resize(true);\n  };\n  SignaturePad.prototype.setOptions = function (options) {\n    Object.assign(this.options, options);\n    this.pathOptions.stroke.color = this.options.color;\n    this.pathOptions.stroke.width = this.options.strokeWidth;\n    if (this.path) {\n      this.path.options.set('stroke.color', this.options.color);\n      this.path.options.set('stroke.width', this.options.strokeWidth);\n    }\n    this.background.options.set('fill.color', this.options.backgroundColor);\n  };\n  SignaturePad.prototype.initSurface = function () {\n    this.surface = Surface.create(this.element, {\n      type: 'canvas'\n    });\n    this.element.style.touchAction = 'none';\n    var scale = this.options.scale;\n    this.rootGroup = new Group({\n      transform: transform().scale(scale, scale)\n    });\n    // The signature is not resizable, store initial dimensions.\n    var width = this.element.offsetWidth || DEFAULT_WIDTH;\n    var height = this.element.offsetHeight || DEFAULT_HEIGHT;\n    this.size = [width, height];\n    this.background = Path.fromRect(new Rect([0, 0], this.size), {\n      fill: {\n        color: this.options.backgroundColor\n      }\n    });\n    this.surface.draw(this.background);\n    this.surface.draw(this.rootGroup);\n  };\n  SignaturePad.prototype.attachEvents = function () {\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.element.addEventListener('pointerdown', this.onPointerDown);\n    this.element.addEventListener('pointermove', this.onPointerMove);\n    this.element.addEventListener('pointerup', this.onPointerUp);\n  };\n  SignaturePad.prototype.detachEvents = function () {\n    this.element.removeEventListener('pointerdown', this.onPointerDown);\n    this.element.removeEventListener('pointermove', this.onPointerMove);\n    this.element.removeEventListener('pointerup', this.onPointerUp);\n  };\n  SignaturePad.prototype.touchPoint = function (e) {\n    var offset = elementOffset(this.element);\n    var pageX = e.pageX;\n    var pageY = e.pageY;\n    var scale = 1 / this.options.scale;\n    return new Point(pageX - offset.left, pageY - offset.top).scale(scale, scale);\n  };\n  SignaturePad.prototype.onPointerDown = function (e) {\n    if (this.options.readonly || !e.isPrimary || !isMainButton(e)) {\n      return;\n    }\n    if (!this.path) {\n      this.path = new MultiPath(this.pathOptions);\n      this.rootGroup.append(this.path);\n    }\n    this.options.onDraw();\n    this.element.setPointerCapture(e.pointerId);\n    var point = this.touchPoint(e);\n    this.points = [point];\n    this.path.moveTo(point);\n  };\n  SignaturePad.prototype.onPointerMove = function (e) {\n    if (!this.points || !e.isPrimary) {\n      return;\n    }\n    var now = new Date().getTime();\n    var elapsed = now - this.lastMoveTime;\n    var minTimeDelta = 1000 / limitValue(this.options.samplingRate, 1, 10000);\n    if (elapsed < minTimeDelta) {\n      return;\n    } else {\n      this.lastMoveTime = now;\n    }\n    var point = this.touchPoint(e);\n    var lastPoint = this.points[this.points.length - 1];\n    var minDelta = 1 / limitValue(this.options.precision, 0.01, 100);\n    if (point.distanceTo(lastPoint) < minDelta) {\n      return;\n    }\n    this.points.push(point);\n    this.path.lineTo(point);\n  };\n  SignaturePad.prototype.onPointerUp = function (e) {\n    if (!e.isPrimary || !this.path || !this.points || this.options.readonly) {\n      return;\n    }\n    if (this.options.smooth) {\n      var segments = Path.curveFromPoints(this.points);\n      this.path.paths.splice(this.path.paths.length - 1, 1, segments);\n    }\n    this.points = null;\n    this.options.onDrawEnd();\n    this.options.onChange(this.pathData);\n  };\n  return SignaturePad;\n}();\nexport { SignaturePad };\nfunction isMainButton(e) {\n  return typeof e.button !== 'number' || e.button === 0;\n}","map":null,"metadata":{},"sourceType":"module"}