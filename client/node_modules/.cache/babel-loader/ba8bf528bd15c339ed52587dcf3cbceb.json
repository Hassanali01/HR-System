{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { dispatchEvent, Keys, classNames, Draggable, getTabIndex, createPropsContext, withPropsContext } from '@progress/kendo-react-common';\nimport { registerForLocalization, provideLocalizationService } from '@progress/kendo-react-intl';\nimport { messages, sliderIncreaseValue, sliderDecreaseValue, sliderDragTitle } from './../messages';\nimport { SLIDER_LABEL_ATTRIBUTE } from './SliderLabel';\nimport { validatePackage } from '@progress/kendo-react-common';\nimport { packageMetadata } from '../package-metadata';\nimport { Button } from '@progress/kendo-react-buttons';\n/** @hidden */\nvar SliderWithoutContext = /** @class */function (_super) {\n  __extends(SliderWithoutContext, _super);\n  function SliderWithoutContext(props) {\n    var _this = _super.call(this, props) || this;\n    /**\n     * @hidden\n     */\n    _this.state = {\n      value: _this.props.defaultValue === undefined ? _this.props.min : _this.props.defaultValue,\n      focused: false,\n      dir: _this.props.dir\n    };\n    _this._sliderTrack = null;\n    _this._element = null;\n    /**\n     * @hidden\n     */\n    _this.buttons = function (props) {\n      if (!props.enabled) {\n        return props.children;\n      }\n      return React.createElement(React.Fragment, null, React.createElement(Button, {\n        className: \"k-button-decrease\",\n        rounded: 'full',\n        icon: _this.props.vertical ? 'caret-alt-down' : 'caret-alt-left',\n        title: props.decrementTitle,\n        onClick: props.decrement\n      }), props.children, React.createElement(Button, {\n        className: \"k-button-increase\",\n        rounded: 'full',\n        icon: _this.props.vertical ? 'caret-alt-up' : 'caret-alt-right',\n        title: props.incrementTitle,\n        onClick: props.increment\n      }));\n    };\n    /**\n     * @hidden\n     */\n    _this.focus = function () {\n      if (_this._element) {\n        _this._element.focus();\n      }\n    };\n    _this.isLabel = function (target) {\n      var currentTarget = target;\n      while (currentTarget) {\n        if (Boolean(currentTarget.getAttribute(SLIDER_LABEL_ATTRIBUTE))) {\n          return true;\n        }\n        currentTarget = currentTarget.parentElement;\n      }\n      return false;\n    };\n    _this.onFocus = function () {\n      _this.setState({\n        focused: true\n      });\n    };\n    _this.onBlur = function () {\n      _this.setState({\n        focused: false\n      });\n    };\n    _this.onKeyDown = function (e) {\n      var newValue = undefined;\n      if (e.keyCode === Keys.left || e.keyCode === Keys.down) {\n        newValue = _this.state.value - (_this.props.step || 0);\n      } else if (e.keyCode === Keys.right || e.keyCode === Keys.up) {\n        newValue = _this.state.value + (_this.props.step || 0);\n      } else if (e.keyCode === Keys.home) {\n        newValue = _this.props.min;\n      } else if (e.keyCode === Keys.end) {\n        newValue = _this.props.max;\n      }\n      if (newValue !== undefined) {\n        e.preventDefault();\n        _this.change(e, newValue);\n      }\n    };\n    _this.decrement = function (e) {\n      e.preventDefault();\n      _this.change(e, _this.state.value - (_this.props.step || 0));\n    };\n    _this.increment = function (e) {\n      e.preventDefault();\n      _this.change(e, _this.state.value + (_this.props.step || 0));\n    };\n    _this.dragStart = function (e) {\n      if (!_this.isLabel(e.event.originalEvent.target)) {\n        if (e.event.isTouch) {\n          e.event.originalEvent.preventDefault();\n        }\n        _this.drag(e);\n      }\n    };\n    _this.dragOver = function (e) {\n      e.event.originalEvent.preventDefault();\n      _this.drag(e);\n    };\n    _this.drag = function (e) {\n      var computed = e.element.getBoundingClientRect();\n      var distance = _this.props.vertical ? computed.bottom - e.event.clientY : _this.state.dir === 'rtl' ? computed.right - e.event.clientX : e.event.clientX - computed.left;\n      var size = _this.props.vertical ? computed.height : computed.width;\n      var percentage = distance / size;\n      _this.change(e, _this.props.min + percentage * (_this.props.max - _this.props.min));\n    };\n    validatePackage(packageMetadata);\n    return _this;\n  }\n  /**\n   * @hidden\n   */\n  SliderWithoutContext.getDerivedStateFromProps = function (props, state) {\n    var value = props.value !== undefined ? props.value : state.value;\n    var min = props.min,\n      max = props.max;\n    return value === undefined ? null : {\n      value: Math.min(Math.max(value, min), max)\n    };\n  };\n  /**\n   * @hidden\n   */\n  SliderWithoutContext.prototype.componentDidMount = function () {\n    if (!this.state.dir && window && this._element) {\n      // Note: getComputedStyle forces reflow\n      var direction = window.getComputedStyle(this._element).direction;\n      if (direction) {\n        this.setState({\n          dir: direction\n        });\n      }\n    }\n  };\n  /**\n   * @hidden\n   */\n  SliderWithoutContext.prototype.render = function () {\n    var _a;\n    var _this = this;\n    var lS = provideLocalizationService(this);\n    var percentValue = (this.state.value - this.props.min) / (this.props.max - this.props.min) * 100;\n    var trackStyles = this.props.vertical ? {\n      marginTop: '0.5rem',\n      marginBottom: '0.5rem'\n    } : {\n      marginLeft: '0.5rem',\n      marginRight: '0.5rem'\n    };\n    var sliderItemsStyle = this.props.vertical ? {\n      paddingTop: 0,\n      height: '100%'\n    } : {};\n    return React.createElement(\"div\", {\n      ref: function ref(el) {\n        return _this._element = el;\n      },\n      dir: this.state.dir,\n      id: this.props.id,\n      style: __assign({\n        gap: 0\n      }, this.props.style),\n      onFocus: this.onFocus,\n      onBlur: this.onBlur,\n      onKeyDown: this.onKeyDown,\n      className: classNames('k-slider k-widget', {\n        'k-focus': this.state.focused,\n        'k-disabled': this.props.disabled,\n        'k-slider-horizontal': !this.props.vertical,\n        'k-slider-vertical': this.props.vertical\n      }, this.props.className)\n    }, React.createElement(this.buttons, {\n      enabled: this.props.buttons,\n      decrement: this.decrement,\n      increment: this.increment,\n      incrementTitle: lS.toLanguageString(sliderIncreaseValue, messages[sliderIncreaseValue]),\n      decrementTitle: lS.toLanguageString(sliderDecreaseValue, messages[sliderDecreaseValue])\n    }, React.createElement(Draggable, {\n      onDrag: this.dragOver,\n      onPress: this.dragStart\n    }, React.createElement(\"div\", {\n      className: \"k-slider-track-wrap\",\n      style: __assign({\n        flexGrow: 1,\n        position: 'relative',\n        touchAction: 'none'\n      }, trackStyles)\n    }, this.props.children && React.createElement(\"ul\", {\n      className: \"k-reset k-slider-items\",\n      style: __assign({\n        margin: 0\n      }, sliderItemsStyle)\n    }, React.Children.map(this.props.children, function (child) {\n      return child && React.cloneElement(child, {\n        position: 100 * (child.props.position - _this.props.min) / (_this.props.max - _this.props.min),\n        vertical: _this.props.vertical\n      }, child.props.children);\n    })), React.createElement(\"div\", {\n      className: \"k-slider-track\",\n      style: this.props.vertical ? {\n        bottom: 0,\n        height: '100%'\n      } : (_a = {}, _a[this.state.dir === 'rtl' ? 'right' : 'left'] = 0, _a.width = '100%', _a),\n      ref: function ref(el) {\n        return _this._sliderTrack = el;\n      }\n    }, React.createElement(\"div\", {\n      className: \"k-slider-selection\",\n      style: this.props.vertical ? {\n        height: percentValue + '%'\n      } : {\n        width: percentValue + '%'\n      }\n    }), React.createElement(\"span\", {\n      role: \"slider\",\n      \"aria-valuemin\": this.props.min,\n      \"aria-valuemax\": this.props.max,\n      \"aria-valuenow\": this.state.value,\n      \"aria-valuetext\": String(this.state.value),\n      \"aria-orientation\": this.props.vertical ? 'vertical' : undefined,\n      \"aria-disabled\": this.props.disabled ? 'true' : undefined,\n      \"aria-labelledby\": this.props.ariaLabelledBy,\n      \"aria-describedby\": this.props.ariaDescribedBy,\n      \"aria-label\": this.props.ariaLabel,\n      tabIndex: getTabIndex(this.props.tabIndex, this.props.disabled, undefined),\n      className: \"k-draghandle\",\n      title: lS.toLanguageString(sliderDragTitle, messages[sliderDragTitle]),\n      style: this.props.vertical ? {\n        bottom: 'calc(' + percentValue + '%)',\n        zIndex: 1\n      } : this.state.dir === 'rtl' ? {\n        right: 'calc(' + percentValue + '% - 13px)',\n        zIndex: 1\n      } : {\n        left: 'calc(' + percentValue + '%)',\n        zIndex: 1\n      }\n    }))))));\n  };\n  Object.defineProperty(SliderWithoutContext.prototype, \"sliderTrack\", {\n    /**\n     * @hidden\n     */\n    get: function get() {\n      return this._sliderTrack;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  SliderWithoutContext.prototype.change = function (e, value) {\n    value = Math.min(Math.max(value, this.props.min), this.props.max);\n    this.setState({\n      value: value\n    });\n    dispatchEvent(this.props.onChange, e, this, {\n      value: value\n    });\n  };\n  SliderWithoutContext.displayName = 'Slider';\n  /**\n   * @hidden\n   */\n  SliderWithoutContext.propTypes = {\n    min: PropTypes.number.isRequired,\n    max: PropTypes.number.isRequired,\n    value: PropTypes.number,\n    vertical: PropTypes.bool,\n    id: PropTypes.string,\n    ariaLabelledBy: PropTypes.string,\n    ariaDescribedBy: PropTypes.string,\n    ariaLabel: PropTypes.string\n    // TODO: validation when buttons is set to true, but no step is provided\n  };\n\n  return SliderWithoutContext;\n}(React.Component);\nexport { SliderWithoutContext };\n/**\n * Represents the PropsContext of the `Slider` component.\n * Used for global configuration of all `Slider` instances.\n *\n * For more information, refer to the [Inputs Props Context]({% slug props-context_inputs %}) article.\n */\nexport var SliderPropsContext = createPropsContext();\n/* eslint-disable @typescript-eslint/no-redeclare -- intentionally naming the component the same as the type */\n/**\n * Represents the [KendoReact Slider component]({% slug overview_slider %}).\n *\n * Accepts properties of type [SliderProps]({% slug api_inputs_sliderprops %}).\n * Obtaining the `ref` returns an object of type [SliderHandle]({% slug api_inputs_sliderhandle %}).\n */\nexport var Slider = withPropsContext(SliderPropsContext, SliderWithoutContext);\nSlider.displayName = 'KendoReactSlider';\nregisterForLocalization(SliderWithoutContext);","map":null,"metadata":{},"sourceType":"module"}