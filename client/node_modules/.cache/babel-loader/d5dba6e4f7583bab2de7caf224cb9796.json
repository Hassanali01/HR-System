{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { classNames, Keys, useDir, useDraggable, getTabIndex, createPropsContext, usePropsContext } from '@progress/kendo-react-common';\nimport { messages, sliderDragTitle } from './../messages';\nimport { useLocalization } from '@progress/kendo-react-intl';\nimport { rangeReducer, RANGE_ACTION } from './range-raducer';\nimport { validatePackage } from '@progress/kendo-react-common';\nimport { packageMetadata } from '../package-metadata';\n/**\n * @hidden\n */\nvar useRange = function useRange(defaultValue, args, callback) {\n  var _a = React.useState(defaultValue),\n    state = _a[0],\n    setState = _a[1];\n  var handleDispatchAction = React.useCallback(function (action) {\n    var newState = rangeReducer(args.state || state, __assign(__assign({}, action), args));\n    if (callback) {\n      callback(newState, action.event);\n    }\n    setState(newState);\n  }, [args, callback]);\n  return [state, handleDispatchAction];\n};\n/**\n * Represents the PropsContext of the `RangeSlider` component.\n * Used for global configuration of all `RangeSlider` instances.\n *\n * For more information, refer to the [Inputs Props Context]({% slug props-context_inputs %}) article.\n */\nexport var RangeSliderPropsContext = createPropsContext();\n/**\n * Represents the [KendoReact RangeSlider component]({% slug overview_rangeslider %}).\n *\n * Accepts properties of type [RangeSliderProps]({% slug api_inputs_rangesliderprops %}).\n * Obtaining the `ref` returns an object of type [RangeSliderHandle]({% slug api_inputs_rangesliderhandle %}).\n */\nexport var RangeSlider = React.forwardRef(function (directProps, ref) {\n  var _a, _b;\n  validatePackage(packageMetadata);\n  var props = usePropsContext(RangeSliderPropsContext, directProps);\n  var target = React.useRef(null);\n  var sliderRef = React.useRef(null);\n  var sliderSelectionRef = React.useRef(null);\n  var startHandle = React.useRef(null);\n  var endHandle = React.useRef(null);\n  var focus = React.useCallback(function () {\n    if (startHandle.current) {\n      startHandle.current.focus();\n    }\n  }, [startHandle]);\n  React.useImperativeHandle(target, function () {\n    return {\n      element: sliderRef.current,\n      focus: focus,\n      props: props\n    };\n  });\n  React.useImperativeHandle(ref, function () {\n    return target.current;\n  });\n  var min = React.useMemo(function () {\n    return props.min;\n  }, [props.min]);\n  var max = React.useMemo(function () {\n    return props.max;\n  }, [props.max]);\n  var step = React.useMemo(function () {\n    return props.step !== undefined ? props.step : defaultProps.step;\n  }, [props.step, defaultProps.step]);\n  var dir = useDir(sliderRef, props.dir);\n  var handleChange = function handleChange(newValue, event) {\n    if (props.onChange && target.current) {\n      props.onChange.call(undefined, {\n        value: newValue,\n        target: target.current,\n        syntheticEvent: event\n      });\n    }\n  };\n  var _c = React.useState(''),\n    currentDrag = _c[0],\n    setCurrentDrag = _c[1];\n  var _d = useRange(props.defaultValue || defaultProps.defaultValue, {\n      min: min,\n      max: max,\n      step: step,\n      state: props.value\n    }, handleChange),\n    stateValue = _d[0],\n    dispatchStateValue = _d[1];\n  var value = React.useMemo(function () {\n    return props.value || stateValue;\n  }, [props.value, stateValue]);\n  var sliderTrackRef = React.useRef(null);\n  var sliderTrackWrapRef = React.useRef(null);\n  var percentStart = React.useMemo(function () {\n    return (value.start - min) / (max - min) * 100;\n  }, [value.start, min, max]);\n  var percentEnd = React.useMemo(function () {\n    return (value.end - min) / (max - min) * 100;\n  }, [value.end, min, max]);\n  var sliderItemsStyle = React.useMemo(function () {\n    return props.vertical ? {\n      paddingTop: 0,\n      height: '100%'\n    } : {};\n  }, [props.vertical]);\n  var trackStyles = React.useMemo(function () {\n    return props.vertical ? {\n      marginTop: '0.5rem',\n      marginBottom: '0.5rem'\n    } : {\n      marginLeft: '0.5rem',\n      marginRight: '0.5rem'\n    };\n  }, [props.vertical]);\n  var localization = useLocalization();\n  var calcNewDistance = React.useCallback(function (event) {\n    if (!sliderTrackWrapRef.current) {\n      return;\n    }\n    var computed = sliderTrackWrapRef.current.getBoundingClientRect();\n    var distance = props.vertical ? computed.bottom - event.clientY : dir === 'rtl' ? computed.right - event.clientX : event.clientX - computed.left;\n    var size = props.vertical ? computed.height : computed.width;\n    var percentage = distance / size;\n    var payload = min + percentage * (max - min);\n    return payload;\n  }, [sliderTrackWrapRef, props.vertical, dir, min, max, stateValue.start, stateValue.end, props.value && props.value.start, props.value && props.value.end]);\n  var calcKey = React.useCallback(function (payload) {\n    if (payload <= value.start) {\n      return 'start';\n    }\n    if (payload >= value.end) {\n      return 'end';\n    }\n    return 2 * payload < value.end + value.start ? 'start' : 'end';\n  }, [stateValue.start, stateValue.end, props.value && props.value.start, props.value && props.value.end]);\n  var handleStartKeyDown = React.useCallback(function (event) {\n    switch (event.keyCode) {\n      case Keys.right:\n        event.preventDefault();\n        dispatchStateValue({\n          type: dir === 'rtl' ? RANGE_ACTION.decrease : RANGE_ACTION.increase,\n          key: 'start',\n          event: event\n        });\n        break;\n      case Keys.up:\n        event.preventDefault();\n        dispatchStateValue({\n          type: RANGE_ACTION.increase,\n          key: 'start',\n          event: event\n        });\n        break;\n      case Keys.left:\n        event.preventDefault();\n        dispatchStateValue({\n          type: dir === 'rtl' ? RANGE_ACTION.increase : RANGE_ACTION.decrease,\n          key: 'start',\n          event: event\n        });\n        break;\n      case Keys.down:\n        event.preventDefault();\n        dispatchStateValue({\n          type: RANGE_ACTION.decrease,\n          key: 'start',\n          event: event\n        });\n        break;\n      case Keys.home:\n        event.preventDefault();\n        dispatchStateValue({\n          type: RANGE_ACTION.min,\n          key: 'start',\n          event: event\n        });\n        break;\n      case Keys.end:\n        event.preventDefault();\n        dispatchStateValue({\n          type: RANGE_ACTION.max,\n          key: 'start',\n          event: event\n        });\n        break;\n      default:\n        break;\n    }\n  }, [dispatchStateValue]);\n  var handleEndKeyDown = React.useCallback(function (event) {\n    switch (event.keyCode) {\n      case Keys.right:\n        event.preventDefault();\n        dispatchStateValue({\n          type: dir === 'rtl' ? RANGE_ACTION.decrease : RANGE_ACTION.increase,\n          key: 'end',\n          event: event\n        });\n        break;\n      case Keys.up:\n        event.preventDefault();\n        dispatchStateValue({\n          type: RANGE_ACTION.increase,\n          key: 'end',\n          event: event\n        });\n        break;\n      case Keys.left:\n        event.preventDefault();\n        dispatchStateValue({\n          type: dir === 'rtl' ? RANGE_ACTION.increase : RANGE_ACTION.decrease,\n          key: 'end',\n          event: event\n        });\n        break;\n      case Keys.down:\n        event.preventDefault();\n        dispatchStateValue({\n          type: RANGE_ACTION.decrease,\n          key: 'end',\n          event: event\n        });\n        break;\n      case Keys.home:\n        event.preventDefault();\n        dispatchStateValue({\n          type: RANGE_ACTION.min,\n          key: 'end',\n          event: event\n        });\n        break;\n      case Keys.end:\n        event.preventDefault();\n        dispatchStateValue({\n          type: RANGE_ACTION.max,\n          key: 'end',\n          event: event\n        });\n        break;\n      default:\n        break;\n    }\n  }, [dispatchStateValue, dir]);\n  var handleTrackPress = React.useCallback(function (event) {\n    var payload = calcNewDistance(event);\n    var key = calcKey(payload);\n    setCurrentDrag(key);\n    key === 'end' ? endHandle.current.focus() : startHandle.current.focus();\n    var action = key === 'end' ? RANGE_ACTION.end : RANGE_ACTION.start;\n    dispatchStateValue({\n      type: action,\n      payload: payload,\n      event: event\n    });\n  }, [props.vertical, min, max, dispatchStateValue]);\n  var handleTrackDrag = function handleTrackDrag(event) {\n    var payload = calcNewDistance(event);\n    var action = currentDrag === 'end' ? RANGE_ACTION.end : RANGE_ACTION.start;\n    dispatchStateValue({\n      type: action,\n      payload: payload,\n      event: event\n    });\n  };\n  var handleTrackRelease = function handleTrackRelease(event) {\n    var payload = calcNewDistance(event);\n    var action = currentDrag === 'end' ? RANGE_ACTION.end : RANGE_ACTION.start;\n    dispatchStateValue({\n      type: action,\n      payload: payload,\n      event: event\n    });\n    setCurrentDrag('');\n  };\n  useDraggable(sliderTrackWrapRef, {\n    onPress: handleTrackPress,\n    onDrag: handleTrackDrag,\n    onRelease: handleTrackRelease\n  });\n  return React.createElement(\"div\", {\n    id: props.id,\n    style: props.style,\n    ref: sliderRef,\n    dir: dir,\n    className: classNames('k-widget k-slider', {\n      'k-rtl': dir === 'rtl',\n      'k-disabled': props.disabled,\n      'k-slider-vertical': props.vertical,\n      'k-slider-horizontal': !props.vertical\n    }, props.className)\n  }, React.createElement(\"div\", {\n    ref: sliderTrackWrapRef,\n    className: \"k-slider-track-wrap\",\n    style: __assign({\n      flexGrow: 1,\n      position: 'relative',\n      touchAction: 'none'\n    }, trackStyles)\n  }, props.children && React.createElement(\"ul\", {\n    className: \"k-reset k-slider-items\",\n    style: __assign({}, sliderItemsStyle)\n  }, React.Children.map(props.children, function (child) {\n    return child && React.cloneElement(child, {\n      position: 100 * (child.props.position - props.min) / (props.max - props.min),\n      vertical: props.vertical\n    }, child.props.children);\n  })), React.createElement(\"div\", {\n    ref: sliderTrackRef,\n    className: \"k-slider-track\",\n    style: props.vertical ? {\n      bottom: 0,\n      height: '100%'\n    } : (_a = {}, _a[dir === 'rtl' ? 'right' : 'left'] = 0, _a.width = '100%', _a)\n  }, percentStart !== null && percentEnd !== null && React.createElement(\"div\", {\n    \"data-selection\": true,\n    ref: sliderSelectionRef,\n    title: \"\".concat(value.start, \" - \").concat(value.end),\n    className: \"k-slider-selection\",\n    style: props.vertical ? {\n      height: percentEnd - percentStart + '%',\n      bottom: percentStart + '%'\n    } : (_b = {}, _b[dir === 'rtl' ? 'right' : 'left'] = percentStart + '%', _b.width = percentEnd - percentStart + '%', _b)\n  }), React.createElement(\"span\", {\n    ref: startHandle,\n    role: \"slider\",\n    tabIndex: getTabIndex(props.startTabIndex, props.disabled, undefined),\n    \"aria-valuemin\": min,\n    \"aria-valuemax\": Math.max(max, value.end),\n    \"aria-valuenow\": value.start,\n    \"aria-disabled\": props.disabled ? 'true' : undefined,\n    \"aria-valuetext\": \"\".concat(value.start, \" - \").concat(value.end),\n    className: \"k-draghandle\",\n    title: localization.toLanguageString(sliderDragTitle, messages[sliderDragTitle]),\n    style: props.vertical ? {\n      bottom: 'calc(' + percentStart + '%)',\n      zIndex: 1\n    } : dir === 'rtl' ? {\n      right: 'calc(' + percentStart + '% - 13px)',\n      zIndex: 1\n    } : {\n      left: 'calc(' + percentStart + '%)',\n      zIndex: 1\n    },\n    onKeyDown: handleStartKeyDown\n  }), React.createElement(\"span\", {\n    ref: endHandle,\n    role: \"slider\",\n    tabIndex: getTabIndex(props.endTabIndex, props.disabled, undefined),\n    \"aria-valuemin\": Math.min(min, value.start),\n    \"aria-valuemax\": max,\n    \"aria-valuenow\": value.end,\n    \"aria-disabled\": props.disabled ? 'true' : undefined,\n    \"aria-valuetext\": \"\".concat(value.start, \" - \").concat(value.end),\n    className: \"k-draghandle\",\n    title: localization.toLanguageString(sliderDragTitle, messages[sliderDragTitle]),\n    style: props.vertical ? {\n      bottom: 'calc(' + percentEnd + '%)',\n      zIndex: 1\n    } : dir === 'rtl' ? {\n      right: 'calc(' + percentEnd + '% - 13px)',\n      zIndex: 1\n    } : {\n      left: 'calc(' + percentEnd + '%)',\n      zIndex: 1\n    },\n    onKeyDown: handleEndKeyDown\n  }))));\n});\nvar propTypes = {\n  value: function value(props, propName, componentName) {\n    if (props.value) {\n      var start = props.value.start;\n      var end = props.value.end;\n      var min = props.min;\n      var max = props.max;\n      if (start > end || start > max || start < min || end > max || end < min || end < start) {\n        return new Error(\"Invalid prop + \".concat(propName, \" supplied to \").concat(componentName, \".\\n                    The { start, end } value must be between the min & max value and { start, end } must be start < end.\\n                    \"));\n      }\n    }\n    return null;\n  },\n  defaultValue: function defaultValue(props, propName, componentName) {\n    if (props.defaultValue) {\n      var start = props.defaultValue.start;\n      var end = props.defaultValue.end;\n      var min = props.min;\n      var max = props.max;\n      if (start > end || start > max || start < min || end > max || end < min || end < start) {\n        return new Error(\"Invalid prop + \".concat(propName, \" supplied to \").concat(componentName, \".\\n                    The { start, end } value must be between the min & max value and { start, end } must be start < end.\\n                    \"));\n      }\n    }\n    return null;\n  },\n  onChange: PropTypes.func,\n  step: PropTypes.number,\n  min: function min(props, propName, componentName) {\n    var prop = props[propName];\n    var min = props.min;\n    var max = props.max;\n    if (min === undefined) {\n      return new Error(\"Invalid prop + \".concat(propName, \" supplied to \").concat(componentName, \".\\n                \").concat(propName, \" value can not be undefined.\\n                \"));\n    }\n    if (prop && min >= max) {\n      return new Error(\"Invalid prop + \".concat(propName, \" supplied to \").concat(componentName, \".\\n                \").concat(propName, \" value can not be equal to or bigger than the max value.\\n                \"));\n    }\n    return null;\n  },\n  max: function max(props, propName, componentName) {\n    var prop = props[propName];\n    var min = props.min;\n    var max = props.max;\n    if (max === undefined) {\n      return new Error(\"Invalid prop + \".concat(propName, \" supplied to \").concat(componentName, \".\\n                \").concat(propName, \" value can not be undefined.\\n                \"));\n    }\n    if (prop && max <= min) {\n      return new Error(\"Invalid prop + \".concat(propName, \" supplied to \").concat(componentName, \".\\n                \").concat(propName, \" value can not be equal to or smaller than the min value.\\n                \"));\n    }\n    return null;\n  },\n  vertical: PropTypes.bool,\n  disabled: PropTypes.bool,\n  dir: PropTypes.oneOf(['ltr', 'rtl'])\n};\nvar defaultProps = {\n  step: 1,\n  defaultValue: {\n    start: 0,\n    end: 0\n  },\n  vertical: false,\n  disabled: false\n};\nRangeSlider.displayName = 'KendoReactRangeSlider';\n// TODO: delete casting when @types/react is updated!\nRangeSlider.propTypes = propTypes;\nRangeSlider.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"module"}