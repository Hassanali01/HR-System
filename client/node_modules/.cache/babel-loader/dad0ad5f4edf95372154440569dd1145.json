{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { ColorPaletteService } from './utils/color-palette.service';\nimport { classNames, Keys, dispatchEvent, guid, getTabIndex, withPropsContext, createPropsContext } from '@progress/kendo-react-common';\nimport { validatePackage } from '@progress/kendo-react-common';\nimport { packageMetadata } from '../package-metadata';\nimport { PALETTEPRESETS } from './models/palette-presets';\nimport { isPresent } from './utils/misc';\nimport { parseColor } from './utils/color-parser';\n/**\n * @hidden\n */\nexport var DEFAULT_TILE_SIZE = 24;\n/**\n * @hidden\n */\nexport var DEFAULT_COLUMNS_COUNT = 10;\n/**\n * @hidden\n */\nexport var DEFAULT_PRESET = 'office';\n/** @hidden */\nvar ColorPaletteWithoutContext = /** @class */function (_super) {\n  __extends(ColorPaletteWithoutContext, _super);\n  function ColorPaletteWithoutContext(props) {\n    var _this = _super.call(this, props) || this;\n    /**\n     * @hidden\n     */\n    _this.wrapper = null;\n    _this.paletteService = null;\n    _this.guid = guid();\n    /**\n     * @hidden\n     */\n    _this.focus = function () {\n      if (_this.wrapper) {\n        _this.wrapper.focus();\n      }\n    };\n    _this.onKeyDown = function (event) {\n      switch (event.keyCode) {\n        case Keys.down:\n          _this.handleCellNavigation(0, 1);\n          break;\n        case Keys.up:\n          _this.handleCellNavigation(0, -1);\n          break;\n        case Keys.right:\n          _this.handleCellNavigation(1, 0);\n          break;\n        case Keys.left:\n          _this.handleCellNavigation(-1, 0);\n          break;\n        case Keys.enter:\n          _this.handleEnter(event);\n          break;\n        default:\n          return;\n      }\n      event.preventDefault();\n    };\n    _this.onColorClick = function (color, event) {\n      if (_this.isUncontrolled) {\n        _this.setState({\n          selectedColor: color,\n          focusedColor: color\n        });\n      } else {\n        _this.setState({\n          focusedColor: color\n        });\n      }\n      _this.dispatchChangeEvent(color, event);\n    };\n    _this.onFocus = function (nativeEvent) {\n      if (!_this.paletteService) {\n        return;\n      }\n      _this.setState({\n        focusedColor: _this.state.selectedColor || _this.paletteService.colorRows[0][0]\n      });\n      if (_this.props.onFocus) {\n        _this.props.onFocus.call(undefined, nativeEvent);\n      }\n    };\n    _this.onBlur = function () {\n      _this.setState({\n        focusedColor: undefined\n      });\n    };\n    validatePackage(packageMetadata);\n    // The empty string for the `value` prop means no selection but controlled mode.\n    _this.state = {\n      selectedColor: _this.props.value !== undefined ? _this.props.value : _this.props.defaultValue,\n      isFirstRender: true\n    };\n    return _this;\n  }\n  /**\n   * @hidden\n   */\n  ColorPaletteWithoutContext.prototype.render = function () {\n    var _this = this;\n    var paletteInfo = this.getPaletteInfo();\n    var svc = this.paletteService = new ColorPaletteService();\n    svc.setColorMatrix(paletteInfo.colors, paletteInfo.columns);\n    var selectedCellCoords = svc.getCellCoordsFor(this.state.selectedColor);\n    var focusedCellCoords = svc.getCellCoordsFor(this.state.focusedColor);\n    var className = classNames('k-colorpalette', {\n      'k-disabled': this.props.disabled\n    });\n    if (paletteInfo.colors.length) {\n      return React.createElement(\"div\", {\n        id: this.props.id,\n        className: className,\n        onFocus: this.onFocus,\n        onBlur: this.onBlur,\n        onKeyDown: this.onKeyDown,\n        \"aria-disabled\": this.props.disabled ? 'true' : undefined,\n        \"aria-labelledby\": this.props.ariaLabelledBy,\n        \"aria-describedby\": this.props.ariaDescribedBy,\n        tabIndex: getTabIndex(this.props.tabIndex, this.props.disabled),\n        ref: function ref(el) {\n          return _this.wrapper = el;\n        }\n      }, React.createElement(\"div\", {\n        className: \"k-colorpalette-table-wrap\",\n        role: \"grid\"\n      }, React.createElement(\"table\", {\n        className: \"k-colorpalette-table k-palette\",\n        role: \"presentation\"\n      }, React.createElement(\"tbody\", {\n        role: \"rowgroup\"\n      }, this.renderRows(svc.colorRows, selectedCellCoords, focusedCellCoords)))));\n    } else {\n      // In this way, the code prevents an eventual focus of the component when no cells are available.\n      // This is needed because upon focus the first cell gets focused.\n      return '';\n    }\n  };\n  /**\n   * @hidden\n   */\n  ColorPaletteWithoutContext.getDerivedStateFromProps = function (props, state) {\n    if (!state.isFirstRender && props.value !== undefined) {\n      // The component is in controlled mode.\n      if (props.value === '' && state.selectedColor !== undefined) {\n        // The selection has to be removed.\n        return {\n          selectedColor: undefined\n        };\n      } else if (props.value !== '' && props.value !== state.selectedColor) {\n        return {\n          selectedColor: props.value\n        };\n      }\n    } else if (state.isFirstRender) {\n      return {\n        isFirstRender: false\n      };\n    }\n    return null;\n  };\n  ColorPaletteWithoutContext.prototype.handleCellNavigation = function (horizontalStep, verticalStep) {\n    if (!this.paletteService) {\n      return;\n    }\n    if (this.focusedColorCooridanates) {\n      var newCoords = this.paletteService.getNextCell(this.focusedColorCooridanates, horizontalStep, verticalStep);\n      this.setState({\n        focusedColor: this.paletteService.getColorAt(newCoords)\n      });\n    } else {\n      this.setState({\n        focusedColor: this.paletteService.colorRows[0][0]\n      });\n    }\n  };\n  ColorPaletteWithoutContext.prototype.handleEnter = function (event) {\n    if (this.isUncontrolled) {\n      this.setState({\n        selectedColor: this.state.focusedColor\n      });\n    }\n    this.dispatchChangeEvent(this.state.focusedColor, event);\n  };\n  ColorPaletteWithoutContext.prototype.dispatchChangeEvent = function (value, event) {\n    dispatchEvent(this.props.onChange, event, this, {\n      value: value,\n      rgbaValue: parseColor(value, 'rgba')\n    });\n  };\n  Object.defineProperty(ColorPaletteWithoutContext.prototype, \"focusedColorCooridanates\", {\n    get: function get() {\n      return this.state.focusedColor && this.paletteService ? this.paletteService.getCellCoordsFor(this.state.focusedColor) : undefined;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ColorPaletteWithoutContext.prototype, \"isUncontrolled\", {\n    get: function get() {\n      return this.props.value === undefined;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  ColorPaletteWithoutContext.prototype.getPaletteInfo = function () {\n    if (typeof this.props.palette === 'string') {\n      var preset = PALETTEPRESETS[this.props.palette];\n      if (isPresent(preset)) {\n        return {\n          colors: preset.colors,\n          columns: this.props.columns || preset.columns || DEFAULT_COLUMNS_COUNT\n        };\n      } else {\n        return {\n          colors: [],\n          columns: 0\n        };\n      }\n    } else {\n      return {\n        colors: this.props.palette || [],\n        columns: this.props.columns || DEFAULT_COLUMNS_COUNT\n      };\n    }\n  };\n  ColorPaletteWithoutContext.prototype.renderRows = function (rows, selectedCellCoords, focusedCellCoords) {\n    var _this = this;\n    return rows.map(function (row, i) {\n      return React.createElement(\"tr\", {\n        role: \"row\",\n        key: i\n      }, _this.renderColumns(row, i, selectedCellCoords, focusedCellCoords));\n    });\n  };\n  ColorPaletteWithoutContext.prototype.renderColumns = function (columns, rowIndex, selectedCellCoords, focusedCellCoords) {\n    var _this = this;\n    var rowIsSelected = selectedCellCoords !== undefined && selectedCellCoords.row === rowIndex;\n    var selectedColumn = selectedCellCoords && selectedCellCoords.col;\n    var rowIsFocused = focusedCellCoords !== undefined && focusedCellCoords.row === rowIndex;\n    var focusedColumn = focusedCellCoords && focusedCellCoords.col;\n    var tileSize = typeof this.props.tileSize !== 'number' ? this.props.tileSize : {\n      width: this.props.tileSize,\n      height: this.props.tileSize\n    };\n    var width = tileSize.width + 'px';\n    var height = tileSize.height + 'px';\n    return columns.map(function (color, i) {\n      var isSelected = rowIsSelected && selectedColumn === i;\n      var className = classNames('k-colorpalette-tile', {\n        'k-selected': isSelected,\n        'k-focus': rowIsFocused && focusedColumn === i\n      });\n      return React.createElement(\"td\", {\n        role: \"gridcell\",\n        className: className,\n        \"aria-label\": color,\n        \"aria-selected\": isSelected ? true : _this.props.disabled ? undefined : false,\n        style: {\n          backgroundColor: color,\n          width: width,\n          height: height,\n          minWidth: width\n        },\n        onClick: function onClick(event) {\n          return _this.onColorClick(color, event);\n        },\n        id: _this.createCellId({\n          row: rowIndex,\n          col: i\n        }),\n        key: i\n      });\n    });\n  };\n  ColorPaletteWithoutContext.prototype.createCellId = function (cellCoords) {\n    return \"\".concat(this.guid, \"_\").concat(cellCoords.row, \"_\").concat(cellCoords.col);\n  };\n  ColorPaletteWithoutContext.displayName = 'ColorPalette';\n  /**\n   * @hidden\n   */\n  ColorPaletteWithoutContext.propTypes = {\n    palette: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string.isRequired), PropTypes.string]),\n    columns: PropTypes.number,\n    tileSize: PropTypes.any,\n    defaultValue: PropTypes.string,\n    value: PropTypes.string,\n    disabled: PropTypes.bool,\n    tabIndex: PropTypes.number,\n    onChange: PropTypes.func,\n    onFocus: PropTypes.func,\n    id: PropTypes.string,\n    ariaLabelledBy: PropTypes.string,\n    ariaDescribedBy: PropTypes.string\n  };\n  /**\n   * @hidden\n   */\n  ColorPaletteWithoutContext.defaultProps = {\n    palette: DEFAULT_PRESET,\n    tileSize: DEFAULT_TILE_SIZE\n  };\n  return ColorPaletteWithoutContext;\n}(React.Component);\nexport { ColorPaletteWithoutContext };\n/**\n * Represents the PropsContext of the `ColorPalette` component.\n * Used for global configuration of all `ColorPalette` instances.\n *\n * For more information, refer to the [Inputs Props Context]({% slug props-context_inputs %}) article.\n */\nexport var ColorPalettePropsContext = createPropsContext();\n/* eslint-disable @typescript-eslint/no-redeclare -- intentionally naming the component the same as the type */\n/**\n * Represents the [KendoReact ColorPalette component]({% slug overview_colorpalette %}).\n *\n * Accepts properties of type [ColorPaletteProps]({% slug api_inputs_colorpaletteprops %}).\n * Obtaining the `ref` returns an object of type [ColorPaletteHandle]({% slug api_inputs_colorpalettehandle %}).\n *\n * ```jsx\n * class App extends React.Component {\n *     render() {\n *         return <ColorPalette palette='basic' />;\n *     }\n * }\n * ReactDOM.render(<App />, document.querySelector('my-app'));\n * ```\n */\nexport var ColorPalette = withPropsContext(ColorPalettePropsContext, ColorPaletteWithoutContext);\nColorPalette.displayName = 'KendoReactColorPalette';","map":null,"metadata":{},"sourceType":"module"}