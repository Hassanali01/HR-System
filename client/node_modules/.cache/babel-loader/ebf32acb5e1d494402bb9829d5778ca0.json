{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { classNames, Keys, useDir, getTabIndex, createPropsContext, usePropsContext, kendoThemeMaps } from '@progress/kendo-react-common';\nimport { validatePackage } from '@progress/kendo-react-common';\nimport { packageMetadata } from '../package-metadata';\nimport { Picker } from './Picker';\nimport { ColorGradient } from './ColorGradient';\nimport { ColorPalette, DEFAULT_PRESET, DEFAULT_TILE_SIZE } from './ColorPalette';\nimport { Button } from '@progress/kendo-react-buttons';\nimport { messages, colorPickerDropdownButtonAriaLabel } from '../messages';\nimport { useLocalization } from '@progress/kendo-react-intl';\n/**\n * @hidden\n */\nvar DEFAULT_GRADIENT_SETTINGS = {\n  opacity: true\n};\n/**\n * @hidden\n */\nvar DEFAULT_PALETTE_SETTINGS = {\n  palette: DEFAULT_PRESET,\n  tileSize: DEFAULT_TILE_SIZE\n};\n/**\n * @hidden\n */\nvar isControlled = function isControlled(prop) {\n  return prop !== undefined;\n};\n/**\n * Represents the PropsContext of the `ColorPicker` component.\n * Used for global configuration of all `ColorPicker` instances.\n *\n * For more information, refer to the [Inputs Props Context]({% slug props-context_inputs %}) article.\n */\nexport var ColorPickerPropsContext = createPropsContext();\n/**\n * Represents the [KendoReact ColorPicker component]({% slug overview_colorpicker %}).\n *\n * @example\n * ```jsx\n * class App extends React.Component {\n *     render() {\n *         return <ColorPicker />;\n *     }\n * }\n * ReactDOM.render(<App />, document.querySelector('my-app'));\n * ```\n */\nexport var ColorPicker = React.forwardRef(function (directProps, target) {\n  var _a, _b;\n  validatePackage(packageMetadata);\n  var props = usePropsContext(ColorPickerPropsContext, directProps);\n  var localization = useLocalization();\n  var _c = props.size,\n    size = _c === void 0 ? defaultProps.size : _c,\n    _d = props.rounded,\n    rounded = _d === void 0 ? defaultProps.rounded : _d,\n    _e = props.fillMode,\n    fillMode = _e === void 0 ? defaultProps.fillMode : _e,\n    popupSettings = props.popupSettings,\n    gradientSettings = props.gradientSettings,\n    paletteSettings = props.paletteSettings,\n    valid = props.valid,\n    disabled = props.disabled,\n    tabIndex = props.tabIndex,\n    view = props.view,\n    icon = props.icon,\n    iconClassName = props.iconClassName,\n    onChange = props.onChange,\n    onFocus = props.onFocus,\n    onBlur = props.onBlur,\n    onActiveColorClick = props.onActiveColorClick;\n  var focusableElementRef = React.useRef(null);\n  var gradientRef = React.useRef(null);\n  var paletteRef = React.useRef(null);\n  var blurTimeoutRef = React.useRef();\n  var buttonRef = React.useRef(null);\n  var focusElement = React.useCallback(function () {\n    if (focusableElementRef.current) {\n      focusableElementRef.current.focus();\n    }\n  }, []);\n  React.useImperativeHandle(target, function () {\n    return {\n      // we agreed that each element will have focus method exposed\n      element: focusableElementRef.current,\n      actionElement: buttonRef.current,\n      focus: focusElement\n    };\n  });\n  var _f = React.useState(false),\n    focused = _f[0],\n    setFocused = _f[1];\n  var _g = React.useState(props.defaultValue),\n    stateValue = _g[0],\n    setStateValue = _g[1];\n  var _h = React.useState(false),\n    stateOpen = _h[0],\n    setStateOpen = _h[1];\n  var isValueControlled = isControlled(props.value);\n  var isOpenControlled = isControlled(props.open);\n  var value = isValueControlled ? props.value : stateValue;\n  var open = isOpenControlled ? props.open : stateOpen;\n  var setOpen = React.useCallback(function (nextOpen, isBlur) {\n    if (!isOpenControlled) {\n      if (!nextOpen && !isBlur && focusableElementRef && focusableElementRef.current) {\n        focusableElementRef.current.focus();\n      }\n      setStateOpen(nextOpen);\n    }\n  }, [isOpenControlled]);\n  var onKeyDownHandler = React.useCallback(function (event) {\n    var altKey = event.altKey,\n      keyCode = event.keyCode;\n    if (keyCode === Keys.esc) {\n      setOpen(false);\n      return;\n    }\n    if (keyCode === Keys.enter && !isOpenControlled) {\n      event.preventDefault();\n      event.stopPropagation();\n      setOpen(!open);\n      return;\n    }\n    if (altKey && (keyCode === Keys.up || keyCode === Keys.down)) {\n      event.preventDefault();\n      event.stopPropagation();\n      if (keyCode === Keys.up && focusableElementRef && focusableElementRef.current) {\n        focusableElementRef.current.focus();\n        setOpen(false);\n      }\n      if (keyCode === Keys.down) {\n        setOpen(true);\n      }\n    }\n  }, [open, isOpenControlled]);\n  var onOpenHandler = React.useCallback(function () {\n    // Skip content autofocus when in controlled mode\n    if (!isOpenControlled) {\n      if (gradientRef.current) {\n        gradientRef.current.focus();\n      } else if (paletteRef.current) {\n        paletteRef.current.focus();\n      }\n    }\n  }, [isOpenControlled]);\n  var onClickHandler = React.useCallback(function () {\n    setOpen(!open, true);\n  }, [open]);\n  var onActiveColorClickHandler = React.useCallback(function (event) {\n    if (onActiveColorClick) {\n      onActiveColorClick.call(undefined, {\n        syntheticEvent: event,\n        nativeEvent: event.nativeEvent,\n        value: value\n      });\n    }\n  }, [onActiveColorClick, value]);\n  var onFocusHandler = React.useCallback(function (event) {\n    if (blurTimeoutRef.current) {\n      clearTimeout(blurTimeoutRef.current);\n      blurTimeoutRef.current = undefined;\n      // case where moving back to input from popup\n      // if (event.target === focusableElementRef.current) {\n      // setOpen(false); // in this case we should focus input on keydown\n      // }\n    } else {\n      setFocused(true);\n    }\n    if (onFocus) {\n      onFocus.call(undefined, {\n        nativeEvent: event.nativeEvent,\n        syntheticEvent: event\n      });\n    }\n  }, [onFocus]);\n  var onBlurTimeout = React.useCallback(function () {\n    setOpen(false, true);\n    setFocused(false);\n    blurTimeoutRef.current = undefined;\n  }, []);\n  var onBlurHandler = React.useCallback(function (event) {\n    clearTimeout(blurTimeoutRef.current);\n    blurTimeoutRef.current = window.setTimeout(onBlurTimeout);\n    if (onBlur) {\n      onBlur.call(undefined, {\n        nativeEvent: event.nativeEvent,\n        syntheticEvent: event\n      });\n    }\n  }, [onBlur]);\n  var onChangeHandler = React.useCallback(function (event, isPalette) {\n    var currentValue = isPalette ? event.rgbaValue : event.value;\n    if (!isValueControlled) {\n      setStateValue(currentValue);\n    }\n    if (isPalette) {\n      setOpen(false);\n    }\n    if (onChange) {\n      onChange.call(undefined, {\n        value: currentValue,\n        nativeEvent: event.nativeEvent,\n        syntheticEvent: event.syntheticEvent\n      });\n    }\n  }, [isValueControlled, onChange]);\n  var onPaletteChangeHandler = React.useCallback(function (event) {\n    return onChangeHandler(event, true);\n  }, [isControlled, onChangeHandler]);\n  var dir = useDir(focusableElementRef, props.dir);\n  var isValid = valid !== false;\n  return React.createElement(\"span\", {\n    id: props.id,\n    \"aria-labelledby\": props.ariaLabelledBy,\n    \"aria-describedby\": props.ariaDescribedBy,\n    className: classNames('k-colorpicker', 'k-picker', 'k-icon-picker', (_a = {}, _a[\"k-picker-\".concat(kendoThemeMaps.sizeMap[size] || size)] = size, _a[\"k-picker-\".concat(fillMode)] = fillMode, _a[\"k-rounded-\".concat(kendoThemeMaps.roundedMap[rounded] || rounded)] = rounded, _a['k-invalid'] = !isValid, _a['k-disabled'] = disabled, _a['k-focus'] = focused, _a)),\n    ref: focusableElementRef,\n    tabIndex: getTabIndex(tabIndex, disabled),\n    title: props.title,\n    onKeyDown: onKeyDownHandler,\n    onFocus: onFocusHandler,\n    onBlur: onBlurHandler,\n    dir: dir\n  }, React.createElement(Picker, {\n    dir: dir,\n    open: open,\n    onOpen: onOpenHandler,\n    popupAnchor: focusableElementRef.current || undefined,\n    popupSettings: __assign({}, popupSettings),\n    input: React.createElement(\"span\", {\n      onClick: onActiveColorClickHandler,\n      className: 'k-input-inner'\n    }, React.createElement(\"span\", {\n      className: classNames('k-value-icon', 'k-color-preview', {\n        'k-no-color': !value,\n        'k-icon-color-preview': icon || iconClassName\n      })\n    }, (iconClassName || icon) && React.createElement(\"span\", {\n      className: classNames('k-color-preview-icon', iconClassName, (_b = {}, _b[\"k-icon k-i-\".concat(icon)] = icon && !iconClassName, _b))\n    }), React.createElement(\"span\", {\n      className: \"k-color-preview-mask\",\n      style: {\n        backgroundColor: value\n      }\n    }))),\n    button: React.createElement(Button, {\n      tabIndex: -1,\n      type: \"button\",\n      onClick: onClickHandler,\n      className: \"k-input-button\",\n      rounded: null,\n      icon: 'caret-alt-down',\n      \"aria-label\": localization.toLanguageString(colorPickerDropdownButtonAriaLabel, messages[colorPickerDropdownButtonAriaLabel])\n    }),\n    content: React.createElement(React.Fragment, null, (view === 'combo' || view === 'gradient') && React.createElement(ColorGradient, __assign({}, gradientSettings, {\n      tabIndex: 0,\n      ref: gradientRef,\n      value: value,\n      onChange: onChangeHandler\n    })), (view === 'combo' || view === 'palette') && React.createElement(ColorPalette, __assign({}, paletteSettings, {\n      ref: paletteRef,\n      value: value,\n      onChange: onPaletteChangeHandler\n    })))\n  }));\n});\nColorPicker.propTypes = {\n  value: PropTypes.string,\n  defaultValue: PropTypes.string,\n  disabled: PropTypes.bool,\n  view: PropTypes.oneOf(['gradient', 'palette', 'combo']),\n  dir: PropTypes.string,\n  id: PropTypes.string,\n  ariaLabelledBy: PropTypes.string,\n  ariaDescribedBy: PropTypes.string,\n  size: PropTypes.oneOf([null, 'small', 'medium', 'large']),\n  rounded: PropTypes.oneOf([null, 'small', 'medium', 'large', 'full']),\n  fillMode: PropTypes.oneOf([null, 'solid', 'flat', 'outline'])\n};\nvar defaultProps = {\n  size: 'medium',\n  rounded: 'medium',\n  fillMode: 'solid',\n  view: 'palette',\n  gradientSettings: DEFAULT_GRADIENT_SETTINGS,\n  paletteSettings: DEFAULT_PALETTE_SETTINGS\n};\nColorPicker.defaultProps = defaultProps;\nColorPicker.displayName = 'KendoColorPicker';","map":null,"metadata":{},"sourceType":"module"}